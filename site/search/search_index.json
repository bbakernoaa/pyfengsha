{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FENGSHA Dust Emission Scheme","text":"<p>This package provides a pure Python implementation (accelerated with Numba) of the NOAA/ARL FENGSHA dust emission model and the GOCART2G scheme. It is designed to be efficient and easy to integrate with xarray-based workflows.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Pure Python: No Fortran compilation required, avoiding complex build steps.</li> <li>High Performance: Uses Numba for JIT compilation, offering performance comparable to Fortran.</li> <li>Xarray Integration: Built-in wrappers for xarray <code>apply_ufunc</code>, allowing easy application over large datasets with Dask support.</li> <li>Multiple Schemes: Includes both FENGSHA and GOCART2G implementations.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>The easiest way to install is using pip from the source directory:</p> <pre><code>git clone https://github.com/yourusername/pyfengsha.git\ncd pyfengsha\npip install .\n</code></pre> <p>To install with dependencies for running examples and building documentation:</p> <pre><code>pip install .[docs,examples]\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here is a simple example of how to use the xarray interface:</p> <pre><code>import xarray as xr\nimport pyfengsha\n\n# Load your data (example)\n# ds = xr.open_dataset(\"your_data.nc\")\n\n# Define parameters\nalpha = 1.0\ngamma = 1.0\nkvhmax = 1.0\ngrav = 9.81\ndrylimit_factor = 1.0\nmoist_correct = 1.0\ndrag_opt = 1\n\n# Call the FENGSHA xarray wrapper\n# Note: Ensure your input DataArrays have the correct dimensions (lat, lon) or (bin)\nemissions = pyfengsha.DustEmissionFENGSHA_xr(\n    fraclake=ds.fraclake,\n    fracsnow=ds.fracsnow,\n    oro=ds.oro,\n    slc=ds.slc,\n    clay=ds.clay,\n    sand=ds.sand,\n    silt=ds.silt,\n    ssm=ds.ssm,\n    rdrag=ds.rdrag,\n    airdens=ds.airdens,\n    ustar=ds.ustar,\n    vegfrac=ds.vegfrac,\n    lai=ds.lai,\n    uthrs=ds.uthrs,\n    alpha=alpha,\n    gamma=gamma,\n    kvhmax=kvhmax,\n    grav=grav,\n    rhop=ds.rhop,\n    distribution=ds.distribution,\n    drylimit_factor=drylimit_factor,\n    moist_correct=moist_correct,\n    drag_opt=drag_opt\n)\n</code></pre> <p>See the Documentation for more detailed examples and API reference.</p>"},{"location":"#references","title":"References","text":"<p>If you use this code, please consider citing the following:</p> <p>FENGSHA Model: *   Tong, D., Dan, M., Wang, T., &amp; Lee, P. (2017). Long-term dust climatology in the western United States reconstructed from satellite observations, ground measurements and model simulations. Aeolian Research, 24, 103-115. *   Developed at NOAA ARL by Daniel Tong and Dale Gillette for NAQFC (2012).</p> <p>GOCART Scheme: *   Ginoux, P., Chin, M., Tegen, I., Prospero, J. M., Holben, B., Dubovik, O., &amp; Lin, S. J. (2001). Sources and distributions of dust aerosols simulated with the GOCART model. Journal of Geophysical Research: Atmospheres, 106(D17), 20255-20273. *   LeGrand, S. L., Polashenski, C., Letcher, T. W., Creighton, G. A., Peckham, S. E., and Cetola, J. D. (2019). The AFWA dust emission scheme for the GOCART aerosol model in WRF-Chem v3.8.1. Geosci. Model Dev., 12, 131\u2013166.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"reference/","title":"API Reference","text":"<p>This reference documentation describes the components of the <code>pyfengsha</code> package.</p>"},{"location":"reference/#core-functions-pyfengshafengsha","title":"Core Functions (<code>pyfengsha.fengsha</code>)","text":"<p>NOAA/ARL FENGSHA dust emission model and GOCART2G scheme implementations.</p>"},{"location":"reference/#pyfengsha.fengsha.DarmenovaDragPartition","title":"<code>DarmenovaDragPartition(Lc, vegfrac, thresh)</code>","text":"<p>Darmenova drag partition scheme.</p> <p>Parameters:</p> Name Type Description Default <code>Lc</code> <code>float</code> <p>Roughness density.</p> required <code>vegfrac</code> <code>float</code> <p>Vegetation fraction.</p> required <code>thresh</code> <code>float</code> <p>Threshold value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Effective drag partition.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef DarmenovaDragPartition(Lc: float, vegfrac: float, thresh: float) -&gt; float:\n    \"\"\"Darmenova drag partition scheme.\n\n    Args:\n        Lc: Roughness density.\n        vegfrac: Vegetation fraction.\n        thresh: Threshold value.\n\n    Returns:\n        Effective drag partition.\n    \"\"\"\n    DRAG_MIN = 1.0e-3\n    sigb = 1.0\n    mb = 0.5\n    Betab = 90.0\n    sigv = 1.45\n    mv = 0.16\n    Betav = 202.0\n\n    if vegfrac &lt; 0.0 or vegfrac &gt;= thresh:\n        feff_veg = DRAG_MIN\n    else:\n        Lc_veg = -0.35 * np.log(1.0 - vegfrac)\n        # calc_drag_partition inline\n        R1 = 1.0 / np.sqrt(1.0 - sigv * mv * Lc_veg)\n        R2 = 1.0 / np.sqrt(1.0 + mv * Betav * Lc_veg)\n        feff_veg = R1 * R2\n\n    Lc_bare = Lc / (1.0 - vegfrac)\n    tmpVal = 1.0 - sigb * mb * Lc_bare\n\n    skip_bare = False\n    if vegfrac &lt; 0.0 or vegfrac &gt;= thresh:\n        skip_bare = True\n    elif (Lc &gt; 0.2) or (tmpVal &lt;= 0.0):\n        skip_bare = True\n\n    if not skip_bare:\n        R1 = 1.0 / np.sqrt(1.0 - sigb * mb * Lc_bare)\n        R2 = 1.0 / np.sqrt(1.0 + mb * Betab * Lc_bare)\n        feff_bare = R1 * R2\n    else:\n        feff_bare = DRAG_MIN\n\n    feff = feff_veg * feff_bare\n\n    if feff &gt; 1.0 or feff &lt; 1.0e-5:\n        return DRAG_MIN\n    else:\n        return feff\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.DustAerosolDistributionKok","title":"<code>DustAerosolDistributionKok(radius, rLow, rUp)</code>","text":"<p>Compute Kok's dust size aerosol distribution.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>ndarray</code> <p>Array of bin radii.</p> required <code>rLow</code> <code>ndarray</code> <p>Lower bounds of bins.</p> required <code>rUp</code> <code>ndarray</code> <p>Upper bounds of bins.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of distribution fractions summing to 1.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef DustAerosolDistributionKok(radius: np.ndarray, rLow: np.ndarray, rUp: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Compute Kok's dust size aerosol distribution.\n\n    Args:\n        radius: Array of bin radii.\n        rLow: Lower bounds of bins.\n        rUp: Upper bounds of bins.\n\n    Returns:\n        Array of distribution fractions summing to 1.\n    \"\"\"\n    medianMassDiameter = 3.4\n    geometricStdDev = 3.0\n    crackPropagationLength = 12.0\n    factor = 1.0 / (np.sqrt(2.0) * np.log(geometricStdDev))\n\n    numBins = len(radius)\n    distribution = np.zeros(numBins)\n    totalVolume = 0.0\n\n    for n in range(numBins):\n        diameter = 2.0 * radius[n]\n        dlam = diameter / crackPropagationLength\n        distribution[n] = diameter * (1.0 + math.erf(factor * np.log(diameter / medianMassDiameter))) * \\\n                          np.exp(-dlam**3) * np.log(rUp[n] / rLow[n])\n        totalVolume += distribution[n]\n\n    for n in range(numBins):\n        distribution[n] = distribution[n] / totalVolume\n\n    return distribution\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.DustEmissionFENGSHA","title":"<code>DustEmissionFENGSHA(fraclake, fracsnow, oro, slc, clay, sand, silt, ssm, rdrag, airdens, ustar, vegfrac, lai, uthrs, alpha, gamma, kvhmax, grav, rhop, distribution, drylimit_factor, moist_correct, drag_opt)</code>","text":"<p>Compute dust emissions using NOAA/ARL FENGSHA model.</p> <p>Parameters:</p> Name Type Description Default <code>fraclake</code> <code>ndarray</code> <p>Fraction of lake coverage.</p> required <code>fracsnow</code> <code>ndarray</code> <p>Fraction of snow coverage.</p> required <code>oro</code> <code>ndarray</code> <p>Land/water mask (1 for land).</p> required <code>slc</code> <code>ndarray</code> <p>Soil liquid content.</p> required <code>clay</code> <code>ndarray</code> <p>Clay fraction.</p> required <code>sand</code> <code>ndarray</code> <p>Sand fraction.</p> required <code>silt</code> <code>ndarray</code> <p>Silt fraction.</p> required <code>ssm</code> <code>ndarray</code> <p>Surface soil moisture.</p> required <code>rdrag</code> <code>ndarray</code> <p>Drag partition parameter.</p> required <code>airdens</code> <code>ndarray</code> <p>Air density.</p> required <code>ustar</code> <code>ndarray</code> <p>Friction velocity.</p> required <code>vegfrac</code> <code>ndarray</code> <p>Vegetation fraction.</p> required <code>lai</code> <code>ndarray</code> <p>Leaf Area Index.</p> required <code>uthrs</code> <code>ndarray</code> <p>Threshold velocity.</p> required <code>alpha</code> <code>float</code> <p>Tuning parameter.</p> required <code>gamma</code> <code>float</code> <p>Tuning parameter.</p> required <code>kvhmax</code> <code>float</code> <p>Max KVH ratio.</p> required <code>grav</code> <code>float</code> <p>Gravity acceleration.</p> required <code>rhop</code> <code>ndarray</code> <p>Particle density per bin.</p> required <code>distribution</code> <code>ndarray</code> <p>Size distribution per bin.</p> required <code>drylimit_factor</code> <code>float</code> <p>Dry limit factor for moisture correction.</p> required <code>moist_correct</code> <code>float</code> <p>Moisture correction factor.</p> required <code>drag_opt</code> <code>int</code> <p>Drag option (1, 2, or 3).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Emissions array of shape (ni, nj, nbins).</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef DustEmissionFENGSHA(fraclake: np.ndarray, fracsnow: np.ndarray, oro: np.ndarray, slc: np.ndarray, clay: np.ndarray, sand: np.ndarray, silt: np.ndarray,\n                        ssm: np.ndarray, rdrag: np.ndarray, airdens: np.ndarray, ustar: np.ndarray, vegfrac: np.ndarray, lai: np.ndarray, uthrs: np.ndarray,\n                        alpha: float, gamma: float, kvhmax: float, grav: float, rhop: np.ndarray, distribution: np.ndarray,\n                        drylimit_factor: float, moist_correct: float, drag_opt: int) -&gt; np.ndarray:\n    \"\"\"Compute dust emissions using NOAA/ARL FENGSHA model.\n\n    Args:\n        fraclake: Fraction of lake coverage.\n        fracsnow: Fraction of snow coverage.\n        oro: Land/water mask (1 for land).\n        slc: Soil liquid content.\n        clay: Clay fraction.\n        sand: Sand fraction.\n        silt: Silt fraction.\n        ssm: Surface soil moisture.\n        rdrag: Drag partition parameter.\n        airdens: Air density.\n        ustar: Friction velocity.\n        vegfrac: Vegetation fraction.\n        lai: Leaf Area Index.\n        uthrs: Threshold velocity.\n        alpha: Tuning parameter.\n        gamma: Tuning parameter.\n        kvhmax: Max KVH ratio.\n        grav: Gravity acceleration.\n        rhop: Particle density per bin.\n        distribution: Size distribution per bin.\n        drylimit_factor: Dry limit factor for moisture correction.\n        moist_correct: Moisture correction factor.\n        drag_opt: Drag option (1, 2, or 3).\n\n    Returns:\n        Emissions array of shape (ni, nj, nbins).\n    \"\"\"\n    SSM_THRESH = 1.0E-02\n    VEG_THRESH = 0.4\n    SMALL = 1.0E-10\n    MAX_RDRAG = 0.3\n    LAND = 1.0\n\n    ni = fraclake.shape[0]\n    nj = fraclake.shape[1]\n    nbins = len(distribution)\n\n    emissions = np.zeros((ni, nj, nbins))\n\n    alpha_grav = alpha / max(grav, SMALL)\n\n    for j in range(nj):\n        for i in range(ni):\n            skip = False\n            if oro[i, j] != LAND:\n                skip = True\n\n            if not skip:\n                if drag_opt == 2:\n                    if (vegfrac[i, j] &lt; 0.0) or (vegfrac[i, j] &gt;= VEG_THRESH) or (rdrag[i, j] &gt; MAX_RDRAG):\n                        skip = True\n                elif drag_opt == 3:\n                    if (vegfrac[i, j] &lt; 0.0) or (lai[i, j] &gt;= VEG_THRESH):\n                        skip = True\n                else:\n                    if rdrag[i, j] &lt; 0.0:\n                        skip = True\n\n            if not skip:\n                if (ssm[i, j] &lt; SSM_THRESH) or (clay[i, j] &lt; 0.0) or (sand[i, j] &lt; 0.0):\n                    skip = True\n\n            if not skip:\n                fracland = max(0.0, min(1.0, 1.0 - fraclake[i, j])) * \\\n                           max(0.0, min(1.0, 1.0 - fracsnow[i, j]))\n\n                kvh = DustFluxV2HRatioMB95(clay[i, j], kvhmax)\n\n                total_emissions = alpha_grav * fracland * (ssm[i, j] ** gamma) * \\\n                                  airdens[i, j] * kvh\n\n                if drag_opt == 1:\n                    R = rdrag[i, j]\n                elif drag_opt == 2:\n                    R = DarmenovaDragPartition(rdrag[i, j], vegfrac[i, j], VEG_THRESH)\n                elif drag_opt == 3:\n                    R = LeungDragPartition(rdrag[i, j], lai[i, j], vegfrac[i, j], VEG_THRESH)\n                else:\n                    R = rdrag[i, j] # Default\n\n                rustar = R * ustar[i, j]\n\n                smois = slc[i, j] * moist_correct\n                h = moistureCorrectionFecan(smois, sand[i, j], clay[i, j], drylimit_factor)\n\n                u_thresh = uthrs[i, j] * h\n                u_sum = rustar + u_thresh\n\n                q = max(0.0, rustar - u_thresh) * u_sum * u_sum\n\n                for n in range(nbins):\n                    emissions[i, j, n] = distribution[n] * total_emissions * q\n\n    return emissions\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.DustEmissionGOCART2G","title":"<code>DustEmissionGOCART2G(radius, fraclake, gwettop, oro, u10m, v10m, Ch_DU, du_src, grav)</code>","text":"<p>Compute dust emissions using GOCART2G scheme.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>ndarray</code> <p>Particle radii.</p> required <code>fraclake</code> <code>ndarray</code> <p>Fraction of lake coverage.</p> required <code>gwettop</code> <code>ndarray</code> <p>Surface wetness.</p> required <code>oro</code> <code>ndarray</code> <p>Land mask.</p> required <code>u10m</code> <code>ndarray</code> <p>10m u-wind component.</p> required <code>v10m</code> <code>ndarray</code> <p>10m v-wind component.</p> required <code>Ch_DU</code> <code>float</code> <p>Dust emission coefficient.</p> required <code>du_src</code> <code>ndarray</code> <p>Dust source function.</p> required <code>grav</code> <code>float</code> <p>Gravity.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Emissions array.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef DustEmissionGOCART2G(radius: np.ndarray, fraclake: np.ndarray, gwettop: np.ndarray, oro: np.ndarray, u10m: np.ndarray, v10m: np.ndarray, Ch_DU: float, du_src: np.ndarray, grav: float) -&gt; np.ndarray:\n    \"\"\"Compute dust emissions using GOCART2G scheme.\n\n    Args:\n        radius: Particle radii.\n        fraclake: Fraction of lake coverage.\n        gwettop: Surface wetness.\n        oro: Land mask.\n        u10m: 10m u-wind component.\n        v10m: 10m v-wind component.\n        Ch_DU: Dust emission coefficient.\n        du_src: Dust source function.\n        grav: Gravity.\n\n    Returns:\n        Emissions array.\n    \"\"\"\n    air_dens = 1.25\n    soil_density = 2650.0\n    LAND = 1.0\n\n    nbins = len(radius)\n    ni = u10m.shape[0]\n    nj = u10m.shape[1]\n\n    emissions = np.zeros((ni, nj, nbins))\n\n    for n in range(nbins):\n        diameter = 2.0 * radius[n]\n\n        u_thresh0 = 0.13 * np.sqrt(soil_density * grav * diameter / air_dens) * \\\n                    np.sqrt(1.0 + 6.0e-7 / (soil_density * grav * diameter**2.5)) / \\\n                    np.sqrt(1.928 * (1331.0 * (100.0 * diameter)**1.56 + 0.38)**0.092 - 1.0)\n\n        for j in range(nj):\n            for i in range(ni):\n                if oro[i, j] != LAND:\n                    continue\n\n                w10m = np.sqrt(u10m[i, j]**2 + v10m[i, j]**2)\n\n                if gwettop[i, j] &lt; 0.5:\n                    u_thresh = max(0.0, u_thresh0 * (1.2 + 0.2 * np.log10(max(1.e-3, gwettop[i, j]))))\n\n                    if w10m &gt; u_thresh:\n                        emissions[i, j, n] = (1.0 - fraclake[i, j]) * w10m**2 * (w10m - u_thresh)\n\n        # Apply scaling and source function\n        for j in range(nj):\n            for i in range(ni):\n                emissions[i, j, n] = Ch_DU * du_src[i, j] * emissions[i, j, n]\n\n    return emissions\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.DustFluxV2HRatioMB95","title":"<code>DustFluxV2HRatioMB95(clay_fraction, max_flux_ratio)</code>","text":"<p>Compute dust flux vertical to horizontal ratio (MB95).</p> <p>Parameters:</p> Name Type Description Default <code>clay_fraction</code> <code>float</code> <p>Fraction of clay in soil.</p> required <code>max_flux_ratio</code> <code>float</code> <p>Maximum flux ratio allowed.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The computed ratio.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef DustFluxV2HRatioMB95(clay_fraction: float, max_flux_ratio: float) -&gt; float:\n    \"\"\"Compute dust flux vertical to horizontal ratio (MB95).\n\n    Args:\n        clay_fraction: Fraction of clay in soil.\n        max_flux_ratio: Maximum flux ratio allowed.\n\n    Returns:\n        The computed ratio.\n    \"\"\"\n    CLAY_THRESHOLD = 0.2\n    if clay_fraction &gt; CLAY_THRESHOLD:\n        return max_flux_ratio\n    else:\n        return 10.0**(13.4 * clay_fraction - 6.0)\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.LeungDragPartition","title":"<code>LeungDragPartition(Lc, lai, gvf, thresh)</code>","text":"<p>Leung drag partition scheme.</p> <p>Parameters:</p> Name Type Description Default <code>Lc</code> <code>float</code> <p>Roughness density.</p> required <code>lai</code> <code>float</code> <p>Leaf Area Index.</p> required <code>gvf</code> <code>float</code> <p>Green Vegetation Fraction.</p> required <code>thresh</code> <code>float</code> <p>Threshold value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Effective drag partition.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef LeungDragPartition(Lc: float, lai: float, gvf: float, thresh: float) -&gt; float:\n    \"\"\"Leung drag partition scheme.\n\n    Args:\n        Lc: Roughness density.\n        lai: Leaf Area Index.\n        gvf: Green Vegetation Fraction.\n        thresh: Threshold value.\n\n    Returns:\n        Effective drag partition.\n    \"\"\"\n    LAI_THR = 0.33\n    C = 4.8\n    F0 = 0.32\n    SIGB = 1.0\n    MB = 0.5\n    BETAB = 90.0\n    MIN_FEFF = 1.0E-5\n    MAX_FEFF = 1.0\n    SMALL = 1.0E-10\n\n    frac_bare = max(min(1.0 - lai / thresh, 1.0), SMALL)\n\n    if (lai &lt;= 0.0) or (lai &gt;= thresh):\n        feff_veg = 0.0\n    else:\n        K = 2.0 * (1.0 / max(1.0 - lai, SMALL) - 1.0)\n        feff_veg = (K + F0 * C) / (K + C)\n\n    if (Lc &lt;= 0.2) and (Lc &gt; 0.0) and (lai &lt; thresh):\n        Lc_bare = Lc / max(frac_bare, SMALL)\n        tmpVal = 1.0 - SIGB * MB * Lc_bare\n\n        if tmpVal &gt; SMALL:\n            Rbare1 = 1.0 / np.sqrt(max(1.0 - SIGB * MB * Lc_bare, SMALL))\n            Rbare2 = 1.0 / np.sqrt(1.0 + BETAB * MB * Lc_bare)\n            feff_bare = Rbare1 * Rbare2\n        else:\n            feff_bare = 0.0\n    else:\n        feff_bare = 0.0\n\n    feff = (gvf * feff_veg**3 + frac_bare * feff_bare**3) ** (1.0/3.0)\n\n    if feff &gt; MAX_FEFF or feff &lt; MIN_FEFF:\n        return MIN_FEFF\n    else:\n        return feff\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.MB95_kvh","title":"<code>MB95_kvh(clay)</code>","text":"<p>Calculate Marticorena and Bergametti (1995) vertical to horizontal flux ratio.</p> <p>Parameters:</p> Name Type Description Default <code>clay</code> <code>float</code> <p>Clay fraction.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Ratio value.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef MB95_kvh(clay: float) -&gt; float:\n    \"\"\"Calculate Marticorena and Bergametti (1995) vertical to horizontal flux ratio.\n\n    Args:\n        clay: Clay fraction.\n\n    Returns:\n        Ratio value.\n    \"\"\"\n    if clay &lt;= 0.2:\n        return 10.0**(13.4 * clay - 6.0)\n    else:\n        return 2.0E-4\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.fecan_dry_limit","title":"<code>fecan_dry_limit(clay)</code>","text":"<p>Calculate the Fecan dry limit.</p> <p>Parameters:</p> Name Type Description Default <code>clay</code> <code>float</code> <p>Fractional clay content.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Dry limit [kg/kg].</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef fecan_dry_limit(clay: float) -&gt; float:\n    \"\"\"Calculate the Fecan dry limit.\n\n    Args:\n        clay: Fractional clay content.\n\n    Returns:\n        Dry limit [kg/kg].\n    \"\"\"\n    if clay &lt;= 0.0:\n        # 1e-4 used as small epsilon\n        drylimit = 14.0 * 1e-4 * 1e-4 + 17.0 * 1e-4\n    else:\n        drylimit = 14.0 * clay * clay + 17.0 * clay\n    return drylimit\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.fecan_moisture_correction","title":"<code>fecan_moisture_correction(vol_soil_moisture, sand, clay, b=1.0)</code>","text":"<p>Calculate the Fecan soil moisture correction.</p> <p>Parameters:</p> Name Type Description Default <code>vol_soil_moisture</code> <code>float</code> <p>Volumetric soil moisture [m3/m3].</p> required <code>sand</code> <code>float</code> <p>Fractional sand content.</p> required <code>clay</code> <code>float</code> <p>Fractional clay content.</p> required <code>b</code> <code>float</code> <p>Dry limit factor.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>float</code> <p>H (correction factor).</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef fecan_moisture_correction(vol_soil_moisture: float, sand: float, clay: float, b: float = 1.0) -&gt; float:\n    \"\"\"Calculate the Fecan soil moisture correction.\n\n    Args:\n        vol_soil_moisture: Volumetric soil moisture [m3/m3].\n        sand: Fractional sand content.\n        clay: Fractional clay content.\n        b: Dry limit factor.\n\n    Returns:\n        H (correction factor).\n    \"\"\"\n    gravsm = volumetric_to_gravimetric(vol_soil_moisture, sand)\n    drylimit = 14.0 * clay * clay + 17.0 * clay\n\n    if gravsm &gt; drylimit:\n        H = np.sqrt(1.0 + 1.21 * (gravsm - drylimit)**0.68)\n    else:\n        H = 1.0\n    return H\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.fengsha","title":"<code>fengsha(rho_phy, smois, ssm, xland, ust, clay, sand, rdrag, u_ts0)</code>","text":"<p>Core Fengsha dust emission calculation.</p> <p>Parameters:</p> Name Type Description Default <code>rho_phy</code> <code>float</code> <p>Physical density parameter.</p> required <code>smois</code> <code>float</code> <p>Soil moisture.</p> required <code>ssm</code> <code>float</code> <p>Surface soil moisture.</p> required <code>xland</code> <code>float</code> <p>Land mask.</p> required <code>ust</code> <code>float</code> <p>Friction velocity.</p> required <code>clay</code> <code>float</code> <p>Clay fraction.</p> required <code>sand</code> <code>float</code> <p>Sand fraction.</p> required <code>rdrag</code> <code>float</code> <p>Drag partition.</p> required <code>u_ts0</code> <code>float</code> <p>Threshold velocity.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Dust emission.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef fengsha(rho_phy: float, smois: float, ssm: float, xland: float, ust: float, clay: float, sand: float, rdrag: float, u_ts0: float) -&gt; float:\n    \"\"\"Core Fengsha dust emission calculation.\n\n    Args:\n        rho_phy: Physical density parameter.\n        smois: Soil moisture.\n        ssm: Surface soil moisture.\n        xland: Land mask.\n        ust: Friction velocity.\n        clay: Clay fraction.\n        sand: Sand fraction.\n        rdrag: Drag partition.\n        u_ts0: Threshold velocity.\n\n    Returns:\n        Dust emission.\n    \"\"\"\n    g0 = 9.81 * 100.0\n    cmb = 1.0\n\n    if xland != 1 or ssm &lt;= 0:\n        return 0.0\n\n    H = fecan_moisture_correction(smois, sand, clay)\n    kvh = MB95_kvh(clay)\n    u_ts = modified_threshold(u_ts0, H, rdrag)\n    Q = fengsha_hflux(ust, u_ts)\n\n    emis_dust = cmb * ssm * rho_phy / g0 * kvh * Q\n    return emis_dust\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.fengsha_albedo","title":"<code>fengsha_albedo(rho_phy, smois, ssm, xland, ust, clay, sand, rdrag, u_ts0)</code>","text":"<p>Calculate dust emission using Fengsha albedo based logic.</p> <p>Parameters:</p> Name Type Description Default <code>rho_phy</code> <code>float</code> <p>Air density or similar physical parameter [kg/m3].</p> required <code>smois</code> <code>float</code> <p>Soil moisture.</p> required <code>ssm</code> <code>float</code> <p>Surface soil moisture availability.</p> required <code>xland</code> <code>float</code> <p>Land mask (1 for land).</p> required <code>ust</code> <code>float</code> <p>Friction velocity.</p> required <code>clay</code> <code>float</code> <p>Clay fraction.</p> required <code>sand</code> <code>float</code> <p>Sand fraction.</p> required <code>rdrag</code> <code>float</code> <p>Drag partition.</p> required <code>u_ts0</code> <code>float</code> <p>Threshold velocity.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Dust emission flux.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef fengsha_albedo(rho_phy: float, smois: float, ssm: float, xland: float, ust: float, clay: float, sand: float, rdrag: float, u_ts0: float) -&gt; float:\n    \"\"\"Calculate dust emission using Fengsha albedo based logic.\n\n    Args:\n        rho_phy: Air density or similar physical parameter [kg/m3].\n        smois: Soil moisture.\n        ssm: Surface soil moisture availability.\n        xland: Land mask (1 for land).\n        ust: Friction velocity.\n        clay: Clay fraction.\n        sand: Sand fraction.\n        rdrag: Drag partition.\n        u_ts0: Threshold velocity.\n\n    Returns:\n        Dust emission flux.\n    \"\"\"\n    g0 = 9.81 * 100.0\n    cmb = 1.0\n\n    # Don't do dust over water or where ssm says not possible\n    if xland != 1 or ssm &lt;= 0:\n        return 0.0\n\n    # soil moisture correction\n    # Using original fecan_moisture_correction logic (implicit b=1)\n    H = fecan_moisture_correction(smois, sand, clay)\n\n    # vertical to horizontal mass flux\n    kvh = MB95_kvh(clay)\n\n    # modified threshold velocity\n    u_ts = modified_threshold(u_ts0, H, rdrag)\n\n    # horizontal mass flux\n    ustar_albedo = ust * rdrag\n    Q = fengsha_hflux(ustar_albedo, u_ts)\n\n    emis_dust = cmb * ssm * rho_phy / g0 * kvh * Q\n    return emis_dust\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.fengsha_hflux","title":"<code>fengsha_hflux(ust, utst)</code>","text":"<p>Calculate Horizontal Saltation Flux Q.</p> <p>Parameters:</p> Name Type Description Default <code>ust</code> <code>float</code> <p>Friction velocity.</p> required <code>utst</code> <code>float</code> <p>Threshold friction velocity.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Horizontal saltation flux.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef fengsha_hflux(ust: float, utst: float) -&gt; float:\n    \"\"\"Calculate Horizontal Saltation Flux Q.\n\n    Args:\n        ust: Friction velocity.\n        utst: Threshold friction velocity.\n\n    Returns:\n        Horizontal saltation flux.\n    \"\"\"\n    return max(0.0, ust * (ust * ust - utst * utst))\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.mackinnon_drag","title":"<code>mackinnon_drag(z0)</code>","text":"<p>Calculate MacKinnon drag partition.</p> <p>Parameters:</p> Name Type Description Default <code>z0</code> <code>float</code> <p>Roughness length.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Drag partition factor.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef mackinnon_drag(z0: float) -&gt; float:\n    \"\"\"Calculate MacKinnon drag partition.\n\n    Args:\n        z0: Roughness length.\n\n    Returns:\n        Drag partition factor.\n    \"\"\"\n    z0s = 1.0e-04\n    return 1.0 - np.log(z0 / z0s) / np.log(0.7 * (12255.0 / z0s) ** 0.8)\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.mb95_drag","title":"<code>mb95_drag(z0)</code>","text":"<p>Calculate Marticorena and Bergametti (1995) drag partition.</p> <p>Parameters:</p> Name Type Description Default <code>z0</code> <code>float</code> <p>Roughness length.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Drag partition factor.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef mb95_drag(z0: float) -&gt; float:\n    \"\"\"Calculate Marticorena and Bergametti (1995) drag partition.\n\n    Args:\n        z0: Roughness length.\n\n    Returns:\n        Drag partition factor.\n    \"\"\"\n    z0s = 1.0e-04\n    return 1.0 - np.log(z0 / z0s) / np.log(0.7 * (10.0 / z0s) ** 0.8)\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.modified_threshold","title":"<code>modified_threshold(u_ts0, H, drag)</code>","text":"<p>Calculate modified threshold velocity.</p> <p>Parameters:</p> Name Type Description Default <code>u_ts0</code> <code>float</code> <p>Threshold friction velocity.</p> required <code>H</code> <code>float</code> <p>Moisture correction factor.</p> required <code>drag</code> <code>float</code> <p>Drag partition factor.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Modified threshold velocity.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef modified_threshold(u_ts0: float, H: float, drag: float) -&gt; float:\n    \"\"\"Calculate modified threshold velocity.\n\n    Args:\n        u_ts0: Threshold friction velocity.\n        H: Moisture correction factor.\n        drag: Drag partition factor.\n\n    Returns:\n        Modified threshold velocity.\n    \"\"\"\n    return u_ts0 * H / drag\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.moistureCorrectionFecan","title":"<code>moistureCorrectionFecan(slc, sand, clay, b)</code>","text":"<p>Calculate GOCART version of moisture correction.</p> <p>Parameters:</p> Name Type Description Default <code>slc</code> <code>float</code> <p>Liquid water content of top soil layer, volumetric fraction [1].</p> required <code>sand</code> <code>float</code> <p>Fractional sand content [1].</p> required <code>clay</code> <code>float</code> <p>Fractional clay content [1].</p> required <code>b</code> <code>float</code> <p>Dry limit factor.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Moisture correction factor.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef moistureCorrectionFecan(slc: float, sand: float, clay: float, b: float) -&gt; float:\n    \"\"\"Calculate GOCART version of moisture correction.\n\n    Args:\n        slc: Liquid water content of top soil layer, volumetric fraction [1].\n        sand: Fractional sand content [1].\n        clay: Fractional clay content [1].\n        b: Dry limit factor.\n\n    Returns:\n        Moisture correction factor.\n    \"\"\"\n    gravimetricSoilMoisture = soilMoistureConvertVol2Grav(slc, sand)\n    fecanDryLimit = b * clay * (14.0 * clay + 17.0)\n\n    return np.sqrt(1.0 + 1.21 * max(0.0, gravimetricSoilMoisture - fecanDryLimit)**0.68)\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.shao_1996_soil_moisture","title":"<code>shao_1996_soil_moisture(w)</code>","text":"<p>Calculate Shao 1996 soil moisture function.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Soil moisture parameter.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Calculated value.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef shao_1996_soil_moisture(w: float) -&gt; float:\n    \"\"\"Calculate Shao 1996 soil moisture function.\n\n    Args:\n        w: Soil moisture parameter.\n\n    Returns:\n        Calculated value.\n    \"\"\"\n    return np.exp(22.7 * w)\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.shao_2004_soil_moisture","title":"<code>shao_2004_soil_moisture(w)</code>","text":"<p>Calculate Shao 2004 soil moisture function.</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>float</code> <p>Soil moisture parameter.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Calculated value.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef shao_2004_soil_moisture(w: float) -&gt; float:\n    \"\"\"Calculate Shao 2004 soil moisture function.\n\n    Args:\n        w: Soil moisture parameter.\n\n    Returns:\n        Calculated value.\n    \"\"\"\n    if w &lt;= 0.03:\n        return np.exp(22.7 * w)\n    else:\n        return np.exp(95.3 * w - 2.029)\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.soilMoistureConvertVol2Grav","title":"<code>soilMoistureConvertVol2Grav(volumetricSoilMoisture, sandFraction)</code>","text":"<p>Convert soil moisture fraction from volumetric to gravimetric.</p> <p>Parameters:</p> Name Type Description Default <code>volumetricSoilMoisture</code> <code>float</code> <p>Volumetric soil moisture fraction [1].</p> required <code>sandFraction</code> <code>float</code> <p>Sand fraction [1].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Gravimetric soil moisture scaled by 100.</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef soilMoistureConvertVol2Grav(volumetricSoilMoisture: float, sandFraction: float) -&gt; float:\n    \"\"\"Convert soil moisture fraction from volumetric to gravimetric.\n\n    Args:\n        volumetricSoilMoisture: Volumetric soil moisture fraction [1].\n        sandFraction: Sand fraction [1].\n\n    Returns:\n        Gravimetric soil moisture scaled by 100.\n    \"\"\"\n    waterDensity = 1000.0\n    particleDensity = 1700.0\n\n    saturatedVolumetricWaterContent = 0.489 - 0.126 * sandFraction\n\n    return 100.0 * volumetricSoilMoisture * waterDensity / (particleDensity * (1.0 - saturatedVolumetricWaterContent))\n</code></pre>"},{"location":"reference/#pyfengsha.fengsha.volumetric_to_gravimetric","title":"<code>volumetric_to_gravimetric(vsoil, sandfrac)</code>","text":"<p>Convert volumetric soil moisture to gravimetric.</p> <p>Parameters:</p> Name Type Description Default <code>vsoil</code> <code>float</code> <p>Volumetric Soil Moisture [m3/m3].</p> required <code>sandfrac</code> <code>float</code> <p>Fractional Sand content [0-1].</p> required <p>Returns:</p> Type Description <code>float</code> <p>Gravimetric soil moisture [kg/kg].</p> Source code in <code>pyfengsha/fengsha.py</code> <pre><code>@jit(nopython=True)\ndef volumetric_to_gravimetric(vsoil: float, sandfrac: float) -&gt; float:\n    \"\"\"Convert volumetric soil moisture to gravimetric.\n\n    Args:\n        vsoil: Volumetric Soil Moisture [m3/m3].\n        sandfrac: Fractional Sand content [0-1].\n\n    Returns:\n        Gravimetric soil moisture [kg/kg].\n    \"\"\"\n    soil_dens = 2650.0\n    water_dens = 1000.0\n\n    # Saturated volumetric water content (sand-dependent) ! [m3 m-3]\n    vsat = 0.489 - 0.00126 * (sandfrac * 100.0)\n\n    # gravimetric soil content\n    grav_soil = vsoil * water_dens / (soil_dens * (1.0 - vsat))\n    return grav_soil\n</code></pre>"},{"location":"reference/#xarray-interface-pyfengshaxarray_interface","title":"Xarray Interface (<code>pyfengsha.xarray_interface</code>)","text":""},{"location":"reference/#pyfengsha.xarray_interface.DustEmissionFENGSHA_xr","title":"<code>DustEmissionFENGSHA_xr(fraclake, fracsnow, oro, slc, clay, sand, silt, ssm, rdrag, airdens, ustar, vegfrac, lai, uthrs, alpha, gamma, kvhmax, grav, rhop, distribution, drylimit_factor, moist_correct, drag_opt)</code>","text":"<p>Xarray wrapper for DustEmissionFENGSHA.</p> <p>Parameters:</p> Name Type Description Default <code>fraclake</code> <code>DataArray</code> <p>Fraction of lake coverage (lat, lon).</p> required <code>fracsnow</code> <code>DataArray</code> <p>Fraction of snow coverage (lat, lon).</p> required <code>oro</code> <code>DataArray</code> <p>Land/water mask (lat, lon).</p> required <code>slc</code> <code>DataArray</code> <p>Soil liquid content (lat, lon).</p> required <code>clay</code> <code>DataArray</code> <p>Clay fraction (lat, lon).</p> required <code>sand</code> <code>DataArray</code> <p>Sand fraction (lat, lon).</p> required <code>silt</code> <code>DataArray</code> <p>Silt fraction (lat, lon).</p> required <code>ssm</code> <code>DataArray</code> <p>Surface soil moisture (lat, lon).</p> required <code>rdrag</code> <code>DataArray</code> <p>Drag partition parameter (lat, lon).</p> required <code>airdens</code> <code>DataArray</code> <p>Air density (lat, lon).</p> required <code>ustar</code> <code>DataArray</code> <p>Friction velocity (lat, lon).</p> required <code>vegfrac</code> <code>DataArray</code> <p>Vegetation fraction (lat, lon).</p> required <code>lai</code> <code>DataArray</code> <p>Leaf Area Index (lat, lon).</p> required <code>uthrs</code> <code>DataArray</code> <p>Threshold velocity (lat, lon).</p> required <code>alpha</code> <code>float</code> <p>Tuning parameter.</p> required <code>gamma</code> <code>float</code> <p>Tuning parameter.</p> required <code>kvhmax</code> <code>float</code> <p>Max KVH ratio.</p> required <code>grav</code> <code>float</code> <p>Gravity acceleration.</p> required <code>rhop</code> <code>DataArray</code> <p>Particle density per bin (bin).</p> required <code>distribution</code> <code>DataArray</code> <p>Size distribution per bin (bin).</p> required <code>drylimit_factor</code> <code>float</code> <p>Dry limit factor for moisture correction.</p> required <code>moist_correct</code> <code>float</code> <p>Moisture correction factor.</p> required <code>drag_opt</code> <code>int</code> <p>Drag option (1, 2, or 3).</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>Dust emission flux (lat, lon, bin).</p> Source code in <code>pyfengsha/xarray_interface.py</code> <pre><code>def DustEmissionFENGSHA_xr(fraclake: xr.DataArray, fracsnow: xr.DataArray, oro: xr.DataArray, slc: xr.DataArray, clay: xr.DataArray, sand: xr.DataArray, silt: xr.DataArray,\n                           ssm: xr.DataArray, rdrag: xr.DataArray, airdens: xr.DataArray, ustar: xr.DataArray, vegfrac: xr.DataArray, lai: xr.DataArray, uthrs: xr.DataArray,\n                           alpha: float, gamma: float, kvhmax: float, grav: float, rhop: xr.DataArray, distribution: xr.DataArray,\n                           drylimit_factor: float, moist_correct: float, drag_opt: int) -&gt; xr.DataArray:\n    \"\"\"Xarray wrapper for DustEmissionFENGSHA.\n\n    Args:\n        fraclake: Fraction of lake coverage (lat, lon).\n        fracsnow: Fraction of snow coverage (lat, lon).\n        oro: Land/water mask (lat, lon).\n        slc: Soil liquid content (lat, lon).\n        clay: Clay fraction (lat, lon).\n        sand: Sand fraction (lat, lon).\n        silt: Silt fraction (lat, lon).\n        ssm: Surface soil moisture (lat, lon).\n        rdrag: Drag partition parameter (lat, lon).\n        airdens: Air density (lat, lon).\n        ustar: Friction velocity (lat, lon).\n        vegfrac: Vegetation fraction (lat, lon).\n        lai: Leaf Area Index (lat, lon).\n        uthrs: Threshold velocity (lat, lon).\n        alpha: Tuning parameter.\n        gamma: Tuning parameter.\n        kvhmax: Max KVH ratio.\n        grav: Gravity acceleration.\n        rhop: Particle density per bin (bin).\n        distribution: Size distribution per bin (bin).\n        drylimit_factor: Dry limit factor for moisture correction.\n        moist_correct: Moisture correction factor.\n        drag_opt: Drag option (1, 2, or 3).\n\n    Returns:\n        Dust emission flux (lat, lon, bin).\n    \"\"\"\n    return xr.apply_ufunc(\n        DustEmissionFENGSHA,\n        fraclake, fracsnow, oro, slc, clay, sand, silt,\n        ssm, rdrag, airdens, ustar, vegfrac, lai, uthrs,\n        alpha, gamma, kvhmax, grav, rhop, distribution,\n        drylimit_factor, moist_correct, drag_opt,\n        input_core_dims=[\n            ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'],\n            ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'],\n            [], [], [], [], ['bin'], ['bin'],\n            [], [], []\n        ],\n        output_core_dims=[['lat', 'lon', 'bin']],\n        vectorize=True,\n        dask='parallelized',\n        output_dtypes=[float]\n    )\n</code></pre>"},{"location":"reference/#pyfengsha.xarray_interface.DustEmissionGOCART2G_xr","title":"<code>DustEmissionGOCART2G_xr(radius, fraclake, gwettop, oro, u10m, v10m, Ch_DU, du_src, grav)</code>","text":"<p>Xarray wrapper for DustEmissionGOCART2G.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>DataArray</code> <p>Particle radii (bin).</p> required <code>fraclake</code> <code>DataArray</code> <p>Fraction of lake coverage (lat, lon).</p> required <code>gwettop</code> <code>DataArray</code> <p>Surface wetness (lat, lon).</p> required <code>oro</code> <code>DataArray</code> <p>Land mask (lat, lon).</p> required <code>u10m</code> <code>DataArray</code> <p>10m u-wind component (lat, lon).</p> required <code>v10m</code> <code>DataArray</code> <p>10m v-wind component (lat, lon).</p> required <code>Ch_DU</code> <code>float</code> <p>Dust emission coefficient.</p> required <code>du_src</code> <code>DataArray</code> <p>Dust source function (lat, lon).</p> required <code>grav</code> <code>float</code> <p>Gravity.</p> required <p>Returns:</p> Type Description <code>DataArray</code> <p>Dust emission flux (lat, lon, bin).</p> Source code in <code>pyfengsha/xarray_interface.py</code> <pre><code>def DustEmissionGOCART2G_xr(radius: xr.DataArray, fraclake: xr.DataArray, gwettop: xr.DataArray, oro: xr.DataArray, u10m: xr.DataArray, v10m: xr.DataArray, Ch_DU: float, du_src: xr.DataArray, grav: float) -&gt; xr.DataArray:\n    \"\"\"Xarray wrapper for DustEmissionGOCART2G.\n\n    Args:\n        radius: Particle radii (bin).\n        fraclake: Fraction of lake coverage (lat, lon).\n        gwettop: Surface wetness (lat, lon).\n        oro: Land mask (lat, lon).\n        u10m: 10m u-wind component (lat, lon).\n        v10m: 10m v-wind component (lat, lon).\n        Ch_DU: Dust emission coefficient.\n        du_src: Dust source function (lat, lon).\n        grav: Gravity.\n\n    Returns:\n        Dust emission flux (lat, lon, bin).\n    \"\"\"\n    return xr.apply_ufunc(\n        DustEmissionGOCART2G,\n        radius, fraclake, gwettop, oro, u10m, v10m, Ch_DU, du_src, grav,\n        input_core_dims=[\n            ['bin'], ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'], ['lat', 'lon'],\n            [], ['lat', 'lon'], []\n        ],\n        output_core_dims=[['lat', 'lon', 'bin']],\n        dask='parallelized',\n        output_dtypes=[float]\n    )\n</code></pre>"},{"location":"examples/gfs_dust_emission/","title":"Driving Dust Emissions with GFS Data","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nimport requests\nimport numpy as np\nimport xarray as xr\nimport matplotlib.pyplot as plt\nimport cartopy.crs as ccrs\nimport cartopy.feature as cfeature\nfrom datetime import datetime, timedelta\n\n# Import the FENGSHA xarray interface\nfrom pyfengsha.xarray_interface import DustEmissionFENGSHA_xr\n</pre> import os import requests import numpy as np import xarray as xr import matplotlib.pyplot as plt import cartopy.crs as ccrs import cartopy.feature as cfeature from datetime import datetime, timedelta  # Import the FENGSHA xarray interface from pyfengsha.xarray_interface import DustEmissionFENGSHA_xr In\u00a0[\u00a0]: Copied! <pre># Configuration\n# Use yesterday's date to ensure file exists on S3\ndate_target = datetime.utcnow() - timedelta(days=1)\nGFS_DATE = date_target.strftime(\"%Y%m%d\") # YYYYMMDD\nGFS_CYCLE = \"00\"      # Cycle (00, 06, 12, 18)\nGFS_FILENAME = f\"gfs.{GFS_DATE}.t{GFS_CYCLE}z.pgrb2.0p25.f000\"\n\n# URL for NOAA GFS S3 bucket\nGFS_URL = f\"https://noaa-gfs-bdp-pds.s3.amazonaws.com/gfs.{GFS_DATE}/{GFS_CYCLE}/atmos/gfs.t{GFS_CYCLE}z.pgrb2.0p25.f000\"\n\ndef download_gfs_data(url, filename):\n    if os.path.exists(filename):\n        print(f\"{filename} already exists.\")\n        return\n\n    print(f\"Downloading {filename} from {url}...\")\n    try:\n        response = requests.get(url, stream=True)\n        response.raise_for_status()\n        with open(filename, 'wb') as f:\n            for chunk in response.iter_content(chunk_size=8192):\n                f.write(chunk)\n        print(\"Download complete.\")\n    except Exception as e:\n        print(f\"Error downloading file: {e}\")\n\ndownload_gfs_data(GFS_URL, GFS_FILENAME)\n</pre> # Configuration # Use yesterday's date to ensure file exists on S3 date_target = datetime.utcnow() - timedelta(days=1) GFS_DATE = date_target.strftime(\"%Y%m%d\") # YYYYMMDD GFS_CYCLE = \"00\"      # Cycle (00, 06, 12, 18) GFS_FILENAME = f\"gfs.{GFS_DATE}.t{GFS_CYCLE}z.pgrb2.0p25.f000\"  # URL for NOAA GFS S3 bucket GFS_URL = f\"https://noaa-gfs-bdp-pds.s3.amazonaws.com/gfs.{GFS_DATE}/{GFS_CYCLE}/atmos/gfs.t{GFS_CYCLE}z.pgrb2.0p25.f000\"  def download_gfs_data(url, filename):     if os.path.exists(filename):         print(f\"{filename} already exists.\")         return      print(f\"Downloading {filename} from {url}...\")     try:         response = requests.get(url, stream=True)         response.raise_for_status()         with open(filename, 'wb') as f:             for chunk in response.iter_content(chunk_size=8192):                 f.write(chunk)         print(\"Download complete.\")     except Exception as e:         print(f\"Error downloading file: {e}\")  download_gfs_data(GFS_URL, GFS_FILENAME) In\u00a0[\u00a0]: Copied! <pre>try:\n    # Open surface level data\n    # We filter by typeOfLevel='surface' or 'depthBelowLandLayer' depending on variable\n    # Friction velocity is usually 'surface'\n    ds_surf = xr.open_dataset(\n        GFS_FILENAME, \n        engine='cfgrib', \n        backend_kwargs={'filter_by_keys': {'typeOfLevel': 'surface'}}\n    )\n    \n    # Soil moisture is often in 'depthBelowLandLayer'\n    ds_soil = xr.open_dataset(\n        GFS_FILENAME, \n        engine='cfgrib', \n        backend_kwargs={'filter_by_keys': {'typeOfLevel': 'depthBelowLandLayer', 'stepType': 'instant'}}\n    )\n\n    print(\"Datasets opened successfully.\")\n    \n    # Extract variables (names depend on cfgrib/eccodes mapping)\n    # Check ds.data_vars to see actual names if unsure\n    \n    # Friction Velocity\n    # GFS often names it 'ust'\n    ustar_da = ds_surf['ust'] \n\n    # Volumetric Soil Moisture (0-0.1m)\n    # GFS often names it 'swvl1' or similar\n    slc_da = ds_soil['swvl1']\n    \n    # Ensure they are on the same grid (they should be for the same GFS file)\n    # We might need to select the specific soil layer if multiple are present in the file\n    \nexcept Exception as e:\n    print(f\"Could not open GRIB file (likely due to missing cfgrib/eccodes or file): {e}\")\n    print(\"Generating MOCK GFS data for demonstration...\")\n    \n    # Mock Grid (Global 1x1)\n    lat = np.linspace(-90, 90, 181)\n    lon = np.linspace(0, 360, 361)\n    dims = ('lat', 'lon')\n    coords = {'lat': lat, 'lon': lon}\n    \n    # Mock USTAR (high in some bands)\n    ustar_val = 0.2 + 0.5 * np.sin(np.linspace(-3, 3, 181)[:, None])**2 * np.ones((181, 361))\n    ustar_da = xr.DataArray(ustar_val, coords=coords, dims=dims, name='ust')\n    \n    # Mock Soil Moisture (dry bands)\n    soilw_val = 0.3 * np.abs(np.cos(np.linspace(-3, 3, 181)[:, None])) * np.ones((181, 361))\n    soilw_val[60:80, :] = 0.05 # Dry band around 30N\n    slc_da = xr.DataArray(soilw_val, coords=coords, dims=dims, name='swvl1')\n\n# Visualize inputs\nfig, ax = plt.subplots(1, 2, figsize=(15, 5))\nustar_da.plot(ax=ax[0], cmap='inferno')\nax[0].set_title('Friction Velocity (m/s)')\nslc_da.plot(ax=ax[1], cmap='Blues')\nax[1].set_title('Soil Moisture (m3/m3)')\nplt.show()\n</pre> try:     # Open surface level data     # We filter by typeOfLevel='surface' or 'depthBelowLandLayer' depending on variable     # Friction velocity is usually 'surface'     ds_surf = xr.open_dataset(         GFS_FILENAME,          engine='cfgrib',          backend_kwargs={'filter_by_keys': {'typeOfLevel': 'surface'}}     )          # Soil moisture is often in 'depthBelowLandLayer'     ds_soil = xr.open_dataset(         GFS_FILENAME,          engine='cfgrib',          backend_kwargs={'filter_by_keys': {'typeOfLevel': 'depthBelowLandLayer', 'stepType': 'instant'}}     )      print(\"Datasets opened successfully.\")          # Extract variables (names depend on cfgrib/eccodes mapping)     # Check ds.data_vars to see actual names if unsure          # Friction Velocity     # GFS often names it 'ust'     ustar_da = ds_surf['ust']       # Volumetric Soil Moisture (0-0.1m)     # GFS often names it 'swvl1' or similar     slc_da = ds_soil['swvl1']          # Ensure they are on the same grid (they should be for the same GFS file)     # We might need to select the specific soil layer if multiple are present in the file      except Exception as e:     print(f\"Could not open GRIB file (likely due to missing cfgrib/eccodes or file): {e}\")     print(\"Generating MOCK GFS data for demonstration...\")          # Mock Grid (Global 1x1)     lat = np.linspace(-90, 90, 181)     lon = np.linspace(0, 360, 361)     dims = ('lat', 'lon')     coords = {'lat': lat, 'lon': lon}          # Mock USTAR (high in some bands)     ustar_val = 0.2 + 0.5 * np.sin(np.linspace(-3, 3, 181)[:, None])**2 * np.ones((181, 361))     ustar_da = xr.DataArray(ustar_val, coords=coords, dims=dims, name='ust')          # Mock Soil Moisture (dry bands)     soilw_val = 0.3 * np.abs(np.cos(np.linspace(-3, 3, 181)[:, None])) * np.ones((181, 361))     soilw_val[60:80, :] = 0.05 # Dry band around 30N     slc_da = xr.DataArray(soilw_val, coords=coords, dims=dims, name='swvl1')  # Visualize inputs fig, ax = plt.subplots(1, 2, figsize=(15, 5)) ustar_da.plot(ax=ax[0], cmap='inferno') ax[0].set_title('Friction Velocity (m/s)') slc_da.plot(ax=ax[1], cmap='Blues') ax[1].set_title('Soil Moisture (m3/m3)') plt.show() In\u00a0[\u00a0]: Copied! <pre># Align all inputs to the meteorological grid\nustar = ustar_da\nslc = slc_da\n\n# 1. Land Mask (ORO) - 1 for Land\n# Simple approximation: assume land where soil moisture is defined or manually set\noro = xr.ones_like(ustar) \n\n# 2. Soil Texture (Clay, Sand, Silt fractions)\n# We set a \"Sandy Loam\" type everywhere for this example\n# Real data sources: STATSGO, FAO\nclay = xr.full_like(ustar, 0.2)  # 20% Clay\nsand = xr.full_like(ustar, 0.5)  # 50% Sand\nsilt = xr.full_like(ustar, 0.3)  # 30% Silt\n\n# 3. Sediment Supply Map (SSM)\n# Factor 0-1 indicating availability of erodible sediment\nssm = xr.ones_like(ustar)\n\n# 4. Drag Partition (Roughness)\n# Lower values (&lt; ~0.1) allow emission. High values (vegetation, rocks) suppress it.\nrdrag = xr.full_like(ustar, 0.01)\n\n# 5. Air Density\nairdens = xr.full_like(ustar, 1.225)\n\n# 6. Vegetation &amp; LAI\n# Used in advanced drag partitioning options. We'll zero them out for now.\nvegfrac = xr.zeros_like(ustar)\nlai = xr.zeros_like(ustar)\n\n# 7. Threshold Velocity Map\n# Baseline threshold friction velocity (often ~0.2 - 0.4 m/s)\nuthrs = xr.full_like(ustar, 0.3) \n\n# 8. Particle Size Distribution\n# The model outputs emissions for specified particle size bins.\n# Let's define 4 bins.\nnbins = 4\n# Particle density (kg/m3)\nrhop = xr.DataArray(np.full(nbins, 2650.0), dims='bin', name='rhop')\n# Mass fraction of each bin (must sum to 1)\ndistribution = xr.DataArray(np.array([0.1, 0.3, 0.4, 0.2]), dims='bin', name='distribution')\n\n# 9. Other Scalar Constants\nalpha = 1.0       # Global tuning constant\ngamma = 1.0       # Emission exponential factor\nkvhmax = 1.0      # Max vertical-to-horizontal flux ratio\ngrav = 9.81\ndrylimit_factor = 1.0\nmoist_correct = 1.0\ndrag_opt = 0      # 0 = Use rdrag directly\n</pre> # Align all inputs to the meteorological grid ustar = ustar_da slc = slc_da  # 1. Land Mask (ORO) - 1 for Land # Simple approximation: assume land where soil moisture is defined or manually set oro = xr.ones_like(ustar)   # 2. Soil Texture (Clay, Sand, Silt fractions) # We set a \"Sandy Loam\" type everywhere for this example # Real data sources: STATSGO, FAO clay = xr.full_like(ustar, 0.2)  # 20% Clay sand = xr.full_like(ustar, 0.5)  # 50% Sand silt = xr.full_like(ustar, 0.3)  # 30% Silt  # 3. Sediment Supply Map (SSM) # Factor 0-1 indicating availability of erodible sediment ssm = xr.ones_like(ustar)  # 4. Drag Partition (Roughness) # Lower values (&lt; ~0.1) allow emission. High values (vegetation, rocks) suppress it. rdrag = xr.full_like(ustar, 0.01)  # 5. Air Density airdens = xr.full_like(ustar, 1.225)  # 6. Vegetation &amp; LAI # Used in advanced drag partitioning options. We'll zero them out for now. vegfrac = xr.zeros_like(ustar) lai = xr.zeros_like(ustar)  # 7. Threshold Velocity Map # Baseline threshold friction velocity (often ~0.2 - 0.4 m/s) uthrs = xr.full_like(ustar, 0.3)   # 8. Particle Size Distribution # The model outputs emissions for specified particle size bins. # Let's define 4 bins. nbins = 4 # Particle density (kg/m3) rhop = xr.DataArray(np.full(nbins, 2650.0), dims='bin', name='rhop') # Mass fraction of each bin (must sum to 1) distribution = xr.DataArray(np.array([0.1, 0.3, 0.4, 0.2]), dims='bin', name='distribution')  # 9. Other Scalar Constants alpha = 1.0       # Global tuning constant gamma = 1.0       # Emission exponential factor kvhmax = 1.0      # Max vertical-to-horizontal flux ratio grav = 9.81 drylimit_factor = 1.0 moist_correct = 1.0 drag_opt = 0      # 0 = Use rdrag directly In\u00a0[\u00a0]: Copied! <pre>print(\"Running FENGSHA Dust Emission Model...\")\nemissions = DustEmissionFENGSHA_xr(\n    fraclake=xr.zeros_like(ustar),\n    fracsnow=xr.zeros_like(ustar),\n    oro=oro,\n    slc=slc,\n    clay=clay,\n    sand=sand,\n    silt=silt,\n    ssm=ssm,\n    rdrag=rdrag,\n    airdens=airdens,\n    ustar=ustar,\n    vegfrac=vegfrac,\n    lai=lai,\n    uthrs=uthrs,\n    alpha=alpha,\n    gamma=gamma,\n    kvhmax=kvhmax,\n    grav=grav,\n    rhop=rhop,\n    distribution=distribution,\n    drylimit_factor=drylimit_factor,\n    moist_correct=moist_correct,\n    drag_opt=drag_opt\n)\nprint(\"Calculation complete.\")\nprint(f\"Output shape: {emissions.shape} (lat, lon, bin)\")\n</pre> print(\"Running FENGSHA Dust Emission Model...\") emissions = DustEmissionFENGSHA_xr(     fraclake=xr.zeros_like(ustar),     fracsnow=xr.zeros_like(ustar),     oro=oro,     slc=slc,     clay=clay,     sand=sand,     silt=silt,     ssm=ssm,     rdrag=rdrag,     airdens=airdens,     ustar=ustar,     vegfrac=vegfrac,     lai=lai,     uthrs=uthrs,     alpha=alpha,     gamma=gamma,     kvhmax=kvhmax,     grav=grav,     rhop=rhop,     distribution=distribution,     drylimit_factor=drylimit_factor,     moist_correct=moist_correct,     drag_opt=drag_opt ) print(\"Calculation complete.\") print(f\"Output shape: {emissions.shape} (lat, lon, bin)\")  In\u00a0[\u00a0]: Copied! <pre># Sum over all particle size bins\ntotal_emission = emissions.sum(dim='bin')\n\n# Plot\nplt.figure(figsize=(12, 7))\nax = plt.axes(projection=ccrs.PlateCarree())\nax.coastlines()\nax.add_feature(cfeature.BORDERS, linestyle=':')\n\n# Plot data, masking zeros for better visualization\ntotal_emission.where(total_emission &gt; 0).plot(\n    ax=ax, \n    transform=ccrs.PlateCarree(),\n    cmap='YlOrRd',\n    cbar_kwargs={'label': 'Dust Flux (kg/m$^2$/s)'},\n    robust=True # Handles outliers in color scaling\n)\n\nplt.title('Total Dust Emission Flux')\nplt.show()\n</pre> # Sum over all particle size bins total_emission = emissions.sum(dim='bin')  # Plot plt.figure(figsize=(12, 7)) ax = plt.axes(projection=ccrs.PlateCarree()) ax.coastlines() ax.add_feature(cfeature.BORDERS, linestyle=':')  # Plot data, masking zeros for better visualization total_emission.where(total_emission &gt; 0).plot(     ax=ax,      transform=ccrs.PlateCarree(),     cmap='YlOrRd',     cbar_kwargs={'label': 'Dust Flux (kg/m$^2$/s)'},     robust=True # Handles outliers in color scaling )  plt.title('Total Dust Emission Flux') plt.show()"},{"location":"examples/gfs_dust_emission/#driving-dust-emissions-with-gfs-data","title":"Driving Dust Emissions with GFS Data\u00b6","text":"<p>This notebook demonstrates how to use <code>pyfengsha</code> to calculate dust emissions using meteorological data from the NOAA Global Forecast System (GFS).</p> <p>We will:</p> <ol> <li>Download a sample GFS GRIB2 file from NOAA.</li> <li>Read the data using <code>xarray</code> and <code>cfgrib</code>.</li> <li>Prepare the necessary inputs for the FENGSHA model (mocking static soil fields for this example).</li> <li>Run the dust emission model.</li> <li>Visualize the results.</li> </ol>"},{"location":"examples/gfs_dust_emission/#1-download-gfs-data","title":"1. Download GFS Data\u00b6","text":"<p>We will download a single time step of GFS data from the NOAA S3 bucket. We look for the 0.25 degree resolution file. We use yesterday's date to ensure data availability.</p>"},{"location":"examples/gfs_dust_emission/#2-read-data-with-xarray-and-cfgrib","title":"2. Read Data with Xarray and Cfgrib\u00b6","text":"<p>We use <code>xarray</code> with the <code>cfgrib</code> engine to read the GRIB2 file. Note that GRIB files often contain multiple vertical coordinate systems (surface, isobaric, etc.), so we may need to filter by keys to open the dataset cleanly.</p> <p>We need:</p> <ul> <li>Friction Velocity (ustar): Often parameter <code>ust</code> or similar at surface.</li> <li>Soil Moisture: Volumetric soil moisture (e.g., <code>swvl1</code> for 0-10cm layer).</li> </ul>"},{"location":"examples/gfs_dust_emission/#3-prepare-model-inputs","title":"3. Prepare Model Inputs\u00b6","text":"<p>The FENGSHA model requires several static fields (soil texture, land mask, etc.) in addition to meteorology. For this example, we will mock these static fields or set them to constant values. In a real application, you would regrid high-resolution datasets (like FAO soil maps) to the GFS grid.</p>"},{"location":"examples/gfs_dust_emission/#4-run-the-dust-emission-model","title":"4. Run the Dust Emission Model\u00b6","text":"<p>We call the <code>DustEmissionFENGSHA_xr</code> wrapper. This function applies the Numba-accelerated kernel over the xarray grid efficiently.</p>"},{"location":"examples/gfs_dust_emission/#5-visualize-results","title":"5. Visualize Results\u00b6","text":"<p>We sum the emissions across all bins to get the total dust flux and plot it on a map.</p>"}]}